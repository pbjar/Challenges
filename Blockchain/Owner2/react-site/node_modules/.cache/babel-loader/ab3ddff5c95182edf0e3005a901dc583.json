{"ast":null,"code":"function _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n/**\n * Used to define the anatomy/parts of a component in a way that provides\n * a consistent API for `className`, css selector and `theming`.\n */\n\n\nexport class Anatomy {\n  constructor(name) {\n    var _this = this;\n\n    this.name = name;\n\n    _defineProperty(this, \"map\", {});\n\n    _defineProperty(this, \"called\", false);\n\n    _defineProperty(this, \"assert\", () => {\n      if (!this.called) {\n        this.called = true;\n        return;\n      }\n\n      throw new Error(\"[anatomy] .part(...) should only be called once. Did you mean to use .extend(...) ?\");\n    });\n\n    _defineProperty(this, \"parts\", function () {\n      _this.assert();\n\n      for (var _len = arguments.length, values = new Array(_len), _key = 0; _key < _len; _key++) {\n        values[_key] = arguments[_key];\n      }\n\n      for (var part of values) {\n        ;\n        _this.map[part] = _this.toPart(part);\n      }\n\n      return _this;\n    });\n\n    _defineProperty(this, \"extend\", function () {\n      for (var _len2 = arguments.length, parts = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        parts[_key2] = arguments[_key2];\n      }\n\n      for (var part of parts) {\n        if (part in _this.map) continue;\n        _this.map[part] = _this.toPart(part);\n      }\n\n      return _this;\n    });\n\n    _defineProperty(this, \"toPart\", part => {\n      var el = [\"container\", \"root\"].includes(part != null ? part : \"\") ? [this.name] : [this.name, part];\n      var attr = el.filter(Boolean).join(\"__\");\n      var className = \"chakra-\" + attr;\n      var partObj = {\n        className,\n        selector: \".\" + className,\n        toString: () => part\n      };\n      return partObj;\n    });\n\n    _defineProperty(this, \"__type\", {});\n  }\n  /**\n   * Prevents user from calling `.parts` multiple times.\n   * It should only be called once.\n   */\n\n  /**\n   * Get all selectors for the component anatomy\n   */\n\n\n  get selectors() {\n    var value = Object.fromEntries(Object.entries(this.map).map(_ref => {\n      var [key, part] = _ref;\n      return [key, part.selector];\n    }));\n    return value;\n  }\n  /**\n   * Get all classNames for the component anatomy\n   */\n\n\n  get classNames() {\n    var value = Object.fromEntries(Object.entries(this.map).map(_ref2 => {\n      var [key, part] = _ref2;\n      return [key, part.className];\n    }));\n    return value;\n  }\n  /**\n   * Get all parts as array of string\n   */\n\n\n  get keys() {\n    return Object.keys(this.map);\n  }\n  /**\n   * Creates the part object for the given part\n   */\n\n\n}\nexport function anatomy(name) {\n  return new Anatomy(name);\n}","map":{"version":3,"sources":["../../src/anatomy.ts"],"names":["constructor","name","values","parts","part","selectors","value","classNames","keys","Object","el","attr","className","partObj","selector","toString"],"mappings":"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","sourcesContent":["/**\n * Used to define the anatomy/parts of a component in a way that provides\n * a consistent API for `className`, css selector and `theming`.\n */\nexport class Anatomy<T extends string = string> {\n  private map: Record<T, Part> = {} as Record<T, Part>\n  private called = false\n\n  constructor(private name: string) {}\n\n  /**\n   * Prevents user from calling `.parts` multiple times.\n   * It should only be called once.\n   */\n  private assert = () => {\n    if (!this.called) {\n      this.called = true\n      return\n    }\n\n    throw new Error(\n      \"[anatomy] .part(...) should only be called once. Did you mean to use .extend(...) ?\",\n    )\n  }\n\n  /**\n   * Add the core parts of the components\n   */\n  public parts = <V extends string>(...values: V[]) => {\n    this.assert()\n    for (const part of values) {\n      ;(this.map as any)[part] = this.toPart(part)\n    }\n    return (this as unknown) as Omit<Anatomy<V>, \"parts\">\n  }\n\n  /**\n   * Extend the component anatomy to includes new parts\n   */\n  public extend = <U extends string>(...parts: U[]) => {\n    for (const part of parts) {\n      if (part in this.map) continue\n      ;(this.map as any)[part] = this.toPart(part)\n    }\n    return (this as unknown) as Omit<Anatomy<T | U>, \"parts\">\n  }\n\n  /**\n   * Get all selectors for the component anatomy\n   */\n  get selectors() {\n    const value = Object.fromEntries(\n      Object.entries(this.map).map(([key, part]) => [\n        key,\n        (part as any).selector,\n      ]),\n    )\n    return value as Record<T, string>\n  }\n\n  /**\n   * Get all classNames for the component anatomy\n   */\n  get classNames() {\n    const value = Object.fromEntries(\n      Object.entries(this.map).map(([key, part]) => [\n        key,\n        (part as any).className,\n      ]),\n    )\n    return value as Record<T, string>\n  }\n\n  /**\n   * Get all parts as array of string\n   */\n  get keys() {\n    return Object.keys(this.map) as T[]\n  }\n\n  /**\n   * Creates the part object for the given part\n   */\n  toPart = (part: string) => {\n    const el = [\"container\", \"root\"].includes(part ?? \"\")\n      ? [this.name]\n      : [this.name, part]\n    const attr = el.filter(Boolean).join(\"__\")\n    const className = `chakra-${attr}`\n\n    const partObj = {\n      className,\n      selector: `.${className}`,\n      toString: () => part,\n    }\n\n    return partObj as typeof partObj & string\n  }\n\n  /**\n   * Used to get the derived type of the anatomy\n   */\n  __type = {} as T\n}\n\ntype Part = {\n  className: string\n  selector: string\n  toString: () => string\n}\n\nexport function anatomy(name: string) {\n  return new Anatomy(name)\n}\n"]},"metadata":{},"sourceType":"module"}