{"ast":null,"code":"// Original licensing for the following methods can be found in the\n// NOTICE file in the root directory of this source tree.\n// See https://github.com/calvellido/focus-options-polyfill\n// See https://github.com/adobe/react-spectrum\nimport { getOwnerDocument } from \"./dom\";\nimport { warn } from \"./function\";\nimport { isActiveElement, isInputElement } from \"./tabbable\";\nexport function focus(element, options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  var {\n    isActive = isActiveElement,\n    nextTick,\n    preventScroll = true,\n    selectTextIfInput = true\n  } = options;\n  if (!element || isActive(element)) return -1;\n\n  function triggerFocus() {\n    if (!element) {\n      warn({\n        condition: true,\n        message: \"[chakra-ui]: can't call focus() on `null` or `undefined` element\"\n      });\n      return;\n    }\n\n    if (supportsPreventScroll()) {\n      element.focus({\n        preventScroll\n      });\n    } else {\n      element.focus();\n\n      if (preventScroll) {\n        var scrollableElements = getScrollableElements(element);\n        restoreScrollPosition(scrollableElements);\n      }\n    }\n\n    if (isInputElement(element) && selectTextIfInput) {\n      element.select();\n    }\n  }\n\n  if (nextTick) {\n    return requestAnimationFrame(triggerFocus);\n  }\n\n  triggerFocus();\n  return -1;\n}\nvar supportsPreventScrollCached = null;\n\nfunction supportsPreventScroll() {\n  if (supportsPreventScrollCached == null) {\n    supportsPreventScrollCached = false;\n\n    try {\n      var div = document.createElement(\"div\");\n      div.focus({\n        get preventScroll() {\n          supportsPreventScrollCached = true;\n          return true;\n        }\n\n      });\n    } catch (e) {// Ignore\n    }\n  }\n\n  return supportsPreventScrollCached;\n}\n\nfunction getScrollableElements(element) {\n  var _doc$defaultView;\n\n  var doc = getOwnerDocument(element);\n  var win = (_doc$defaultView = doc.defaultView) != null ? _doc$defaultView : window;\n  var parent = element.parentNode;\n  var scrollableElements = [];\n  var rootScrollingElement = doc.scrollingElement || doc.documentElement;\n\n  while (parent instanceof win.HTMLElement && parent !== rootScrollingElement) {\n    if (parent.offsetHeight < parent.scrollHeight || parent.offsetWidth < parent.scrollWidth) {\n      scrollableElements.push({\n        element: parent,\n        scrollTop: parent.scrollTop,\n        scrollLeft: parent.scrollLeft\n      });\n    }\n\n    parent = parent.parentNode;\n  }\n\n  if (rootScrollingElement instanceof win.HTMLElement) {\n    scrollableElements.push({\n      element: rootScrollingElement,\n      scrollTop: rootScrollingElement.scrollTop,\n      scrollLeft: rootScrollingElement.scrollLeft\n    });\n  }\n\n  return scrollableElements;\n}\n\nfunction restoreScrollPosition(scrollableElements) {\n  for (var {\n    element,\n    scrollTop,\n    scrollLeft\n  } of scrollableElements) {\n    element.scrollTop = scrollTop;\n    element.scrollLeft = scrollLeft;\n  }\n}","map":{"version":3,"sources":["../../src/focus.ts"],"names":["options","isActive","preventScroll","selectTextIfInput","warn","condition","message","supportsPreventScroll","element","scrollableElements","getScrollableElements","restoreScrollPosition","isInputElement","requestAnimationFrame","triggerFocus","supportsPreventScrollCached","div","document","doc","getOwnerDocument","win","parent","rootScrollingElement","scrollTop","scrollLeft"],"mappings":"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","sourcesContent":["// Original licensing for the following methods can be found in the\n// NOTICE file in the root directory of this source tree.\n// See https://github.com/calvellido/focus-options-polyfill\n// See https://github.com/adobe/react-spectrum\n\nimport { getOwnerDocument } from \"./dom\"\nimport { warn } from \"./function\"\nimport { FocusableElement, isActiveElement, isInputElement } from \"./tabbable\"\n\nexport interface ExtendedFocusOptions extends FocusOptions {\n  /**\n   * Function that determines if the element is the active element\n   */\n  isActive?: typeof isActiveElement\n  /**\n   * If true, the element will be focused in the next tick\n   */\n  nextTick?: boolean\n  /**\n   * If true and element is an input element, the input's text will be selected\n   */\n  selectTextIfInput?: boolean\n}\n\nexport function focus(\n  element: FocusableElement | null,\n  options: ExtendedFocusOptions = {},\n) {\n  const {\n    isActive = isActiveElement,\n    nextTick,\n    preventScroll = true,\n    selectTextIfInput = true,\n  } = options\n\n  if (!element || isActive(element)) return -1\n\n  function triggerFocus() {\n    if (!element) {\n      warn({\n        condition: true,\n        message:\n          \"[chakra-ui]: can't call focus() on `null` or `undefined` element\",\n      })\n      return\n    }\n    if (supportsPreventScroll()) {\n      element.focus({ preventScroll })\n    } else {\n      element.focus()\n      if (preventScroll) {\n        const scrollableElements = getScrollableElements(element as HTMLElement)\n        restoreScrollPosition(scrollableElements)\n      }\n    }\n\n    if (isInputElement(element) && selectTextIfInput) {\n      element.select()\n    }\n  }\n\n  if (nextTick) {\n    return requestAnimationFrame(triggerFocus)\n  }\n\n  triggerFocus()\n  return -1\n}\n\nlet supportsPreventScrollCached: boolean | null = null\nfunction supportsPreventScroll() {\n  if (supportsPreventScrollCached == null) {\n    supportsPreventScrollCached = false\n    try {\n      const div = document.createElement(\"div\")\n      div.focus({\n        get preventScroll() {\n          supportsPreventScrollCached = true\n          return true\n        },\n      })\n    } catch (e) {\n      // Ignore\n    }\n  }\n\n  return supportsPreventScrollCached\n}\n\ninterface ScrollableElement {\n  element: HTMLElement\n  scrollTop: number\n  scrollLeft: number\n}\n\nfunction getScrollableElements(element: HTMLElement): ScrollableElement[] {\n  const doc = getOwnerDocument(element)\n  const win = doc.defaultView ?? window\n  let parent = element.parentNode\n  const scrollableElements: ScrollableElement[] = []\n  const rootScrollingElement = doc.scrollingElement || doc.documentElement\n\n  while (parent instanceof win.HTMLElement && parent !== rootScrollingElement) {\n    if (\n      parent.offsetHeight < parent.scrollHeight ||\n      parent.offsetWidth < parent.scrollWidth\n    ) {\n      scrollableElements.push({\n        element: parent,\n        scrollTop: parent.scrollTop,\n        scrollLeft: parent.scrollLeft,\n      })\n    }\n    parent = parent.parentNode\n  }\n\n  if (rootScrollingElement instanceof win.HTMLElement) {\n    scrollableElements.push({\n      element: rootScrollingElement,\n      scrollTop: rootScrollingElement.scrollTop,\n      scrollLeft: rootScrollingElement.scrollLeft,\n    })\n  }\n\n  return scrollableElements\n}\n\nfunction restoreScrollPosition(scrollableElements: ScrollableElement[]) {\n  for (const { element, scrollTop, scrollLeft } of scrollableElements) {\n    element.scrollTop = scrollTop\n    element.scrollLeft = scrollLeft\n  }\n}\n"]},"metadata":{},"sourceType":"module"}