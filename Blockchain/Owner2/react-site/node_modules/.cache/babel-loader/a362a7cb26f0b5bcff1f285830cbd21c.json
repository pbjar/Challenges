{"ast":null,"code":"import { focusManager } from './focusManager';\nimport { onlineManager } from './onlineManager';\nimport { sleep } from './utils'; // TYPES\n\nfunction defaultRetryDelay(failureCount) {\n  return Math.min(1000 * Math.pow(2, failureCount), 30000);\n}\n\nexport function isCancelable(value) {\n  return typeof (value == null ? void 0 : value.cancel) === 'function';\n}\nexport var CancelledError = function CancelledError(options) {\n  this.revert = options == null ? void 0 : options.revert;\n  this.silent = options == null ? void 0 : options.silent;\n};\nexport function isCancelledError(value) {\n  return value instanceof CancelledError;\n} // CLASS\n\nexport var Retryer = function Retryer(config) {\n  var _this = this;\n\n  var cancelRetry = false;\n  var cancelFn;\n  var continueFn;\n  var promiseResolve;\n  var promiseReject;\n\n  this.cancel = function (cancelOptions) {\n    return cancelFn == null ? void 0 : cancelFn(cancelOptions);\n  };\n\n  this.cancelRetry = function () {\n    cancelRetry = true;\n  };\n\n  this.continue = function () {\n    return continueFn == null ? void 0 : continueFn();\n  };\n\n  this.failureCount = 0;\n  this.isPaused = false;\n  this.isResolved = false;\n  this.isTransportCancelable = false;\n  this.promise = new Promise(function (outerResolve, outerReject) {\n    promiseResolve = outerResolve;\n    promiseReject = outerReject;\n  });\n\n  var resolve = function resolve(value) {\n    if (!_this.isResolved) {\n      _this.isResolved = true;\n      config.onSuccess == null ? void 0 : config.onSuccess(value);\n      continueFn == null ? void 0 : continueFn();\n      promiseResolve(value);\n    }\n  };\n\n  var reject = function reject(value) {\n    if (!_this.isResolved) {\n      _this.isResolved = true;\n      config.onError == null ? void 0 : config.onError(value);\n      continueFn == null ? void 0 : continueFn();\n      promiseReject(value);\n    }\n  };\n\n  var pause = function pause() {\n    return new Promise(function (continueResolve) {\n      continueFn = continueResolve;\n      _this.isPaused = true;\n      config.onPause == null ? void 0 : config.onPause();\n    }).then(function () {\n      continueFn = undefined;\n      _this.isPaused = false;\n      config.onContinue == null ? void 0 : config.onContinue();\n    });\n  }; // Create loop function\n\n\n  var run = function run() {\n    // Do nothing if already resolved\n    if (_this.isResolved) {\n      return;\n    }\n\n    var promiseOrValue; // Execute query\n\n    try {\n      promiseOrValue = config.fn();\n    } catch (error) {\n      promiseOrValue = Promise.reject(error);\n    } // Create callback to cancel this fetch\n\n\n    cancelFn = function cancelFn(cancelOptions) {\n      if (!_this.isResolved) {\n        reject(new CancelledError(cancelOptions)); // Cancel transport if supported\n\n        if (isCancelable(promiseOrValue)) {\n          try {\n            promiseOrValue.cancel();\n          } catch (_unused) {}\n        }\n      }\n    }; // Check if the transport layer support cancellation\n\n\n    _this.isTransportCancelable = isCancelable(promiseOrValue);\n    Promise.resolve(promiseOrValue).then(resolve).catch(function (error) {\n      var _config$retry, _config$retryDelay; // Stop if the fetch is already resolved\n\n\n      if (_this.isResolved) {\n        return;\n      } // Do we need to retry the request?\n\n\n      var retry = (_config$retry = config.retry) != null ? _config$retry : 3;\n      var retryDelay = (_config$retryDelay = config.retryDelay) != null ? _config$retryDelay : defaultRetryDelay;\n      var delay = typeof retryDelay === 'function' ? retryDelay(_this.failureCount, error) : retryDelay;\n      var shouldRetry = retry === true || typeof retry === 'number' && _this.failureCount < retry || typeof retry === 'function' && retry(_this.failureCount, error);\n\n      if (cancelRetry || !shouldRetry) {\n        // We are done if the query does not need to be retried\n        reject(error);\n        return;\n      }\n\n      _this.failureCount++; // Notify on fail\n\n      config.onFail == null ? void 0 : config.onFail(_this.failureCount, error); // Delay\n\n      sleep(delay) // Pause if the document is not visible or when the device is offline\n      .then(function () {\n        if (!focusManager.isFocused() || !onlineManager.isOnline()) {\n          return pause();\n        }\n      }).then(function () {\n        if (cancelRetry) {\n          reject(error);\n        } else {\n          run();\n        }\n      });\n    });\n  }; // Start loop\n\n\n  run();\n};","map":{"version":3,"sources":["/home/mark/Desktop/Challenges/Blockchain/Owner2/react-site/node_modules/react-query/es/core/retryer.js"],"names":["focusManager","onlineManager","sleep","defaultRetryDelay","failureCount","Math","min","pow","isCancelable","value","cancel","CancelledError","options","revert","silent","isCancelledError","Retryer","config","_this","cancelRetry","cancelFn","continueFn","promiseResolve","promiseReject","cancelOptions","continue","isPaused","isResolved","isTransportCancelable","promise","Promise","outerResolve","outerReject","resolve","onSuccess","reject","onError","pause","continueResolve","onPause","then","undefined","onContinue","run","promiseOrValue","fn","error","_unused","catch","_config$retry","_config$retryDelay","retry","retryDelay","delay","shouldRetry","onFail","isFocused","isOnline"],"mappings":"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","sourcesContent":["import { focusManager } from './focusManager';\nimport { onlineManager } from './onlineManager';\nimport { sleep } from './utils'; // TYPES\n\nfunction defaultRetryDelay(failureCount) {\n  return Math.min(1000 * Math.pow(2, failureCount), 30000);\n}\n\nexport function isCancelable(value) {\n  return typeof (value == null ? void 0 : value.cancel) === 'function';\n}\nexport var CancelledError = function CancelledError(options) {\n  this.revert = options == null ? void 0 : options.revert;\n  this.silent = options == null ? void 0 : options.silent;\n};\nexport function isCancelledError(value) {\n  return value instanceof CancelledError;\n} // CLASS\n\nexport var Retryer = function Retryer(config) {\n  var _this = this;\n\n  var cancelRetry = false;\n  var cancelFn;\n  var continueFn;\n  var promiseResolve;\n  var promiseReject;\n\n  this.cancel = function (cancelOptions) {\n    return cancelFn == null ? void 0 : cancelFn(cancelOptions);\n  };\n\n  this.cancelRetry = function () {\n    cancelRetry = true;\n  };\n\n  this.continue = function () {\n    return continueFn == null ? void 0 : continueFn();\n  };\n\n  this.failureCount = 0;\n  this.isPaused = false;\n  this.isResolved = false;\n  this.isTransportCancelable = false;\n  this.promise = new Promise(function (outerResolve, outerReject) {\n    promiseResolve = outerResolve;\n    promiseReject = outerReject;\n  });\n\n  var resolve = function resolve(value) {\n    if (!_this.isResolved) {\n      _this.isResolved = true;\n      config.onSuccess == null ? void 0 : config.onSuccess(value);\n      continueFn == null ? void 0 : continueFn();\n      promiseResolve(value);\n    }\n  };\n\n  var reject = function reject(value) {\n    if (!_this.isResolved) {\n      _this.isResolved = true;\n      config.onError == null ? void 0 : config.onError(value);\n      continueFn == null ? void 0 : continueFn();\n      promiseReject(value);\n    }\n  };\n\n  var pause = function pause() {\n    return new Promise(function (continueResolve) {\n      continueFn = continueResolve;\n      _this.isPaused = true;\n      config.onPause == null ? void 0 : config.onPause();\n    }).then(function () {\n      continueFn = undefined;\n      _this.isPaused = false;\n      config.onContinue == null ? void 0 : config.onContinue();\n    });\n  }; // Create loop function\n\n\n  var run = function run() {\n    // Do nothing if already resolved\n    if (_this.isResolved) {\n      return;\n    }\n\n    var promiseOrValue; // Execute query\n\n    try {\n      promiseOrValue = config.fn();\n    } catch (error) {\n      promiseOrValue = Promise.reject(error);\n    } // Create callback to cancel this fetch\n\n\n    cancelFn = function cancelFn(cancelOptions) {\n      if (!_this.isResolved) {\n        reject(new CancelledError(cancelOptions)); // Cancel transport if supported\n\n        if (isCancelable(promiseOrValue)) {\n          try {\n            promiseOrValue.cancel();\n          } catch (_unused) {}\n        }\n      }\n    }; // Check if the transport layer support cancellation\n\n\n    _this.isTransportCancelable = isCancelable(promiseOrValue);\n    Promise.resolve(promiseOrValue).then(resolve).catch(function (error) {\n      var _config$retry, _config$retryDelay;\n\n      // Stop if the fetch is already resolved\n      if (_this.isResolved) {\n        return;\n      } // Do we need to retry the request?\n\n\n      var retry = (_config$retry = config.retry) != null ? _config$retry : 3;\n      var retryDelay = (_config$retryDelay = config.retryDelay) != null ? _config$retryDelay : defaultRetryDelay;\n      var delay = typeof retryDelay === 'function' ? retryDelay(_this.failureCount, error) : retryDelay;\n      var shouldRetry = retry === true || typeof retry === 'number' && _this.failureCount < retry || typeof retry === 'function' && retry(_this.failureCount, error);\n\n      if (cancelRetry || !shouldRetry) {\n        // We are done if the query does not need to be retried\n        reject(error);\n        return;\n      }\n\n      _this.failureCount++; // Notify on fail\n\n      config.onFail == null ? void 0 : config.onFail(_this.failureCount, error); // Delay\n\n      sleep(delay) // Pause if the document is not visible or when the device is offline\n      .then(function () {\n        if (!focusManager.isFocused() || !onlineManager.isOnline()) {\n          return pause();\n        }\n      }).then(function () {\n        if (cancelRetry) {\n          reject(error);\n        } else {\n          run();\n        }\n      });\n    });\n  }; // Start loop\n\n\n  run();\n};"]},"metadata":{},"sourceType":"module"}